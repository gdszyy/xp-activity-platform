_# XP通用活动平台设计验证案例_

**版本:** 1.0
**日期:** 2026年1月19日
**作者:** Manus AI

---

## 1. 验证目标

本案例旨在通过一个完整的、端到端的活动创建与执行流程，来检验v2.0设计方案（多层模板体系）的**可行性、灵活性与健壮性**。我们将模拟高阶运营创建原子模板，再由一线运营组合配置活动，最终验证C端用户参与活动时的数据流转与功能表现是否符合预期。

---

## 2. 常规活动场景定义

我们选择一个在各类产品中极为普遍的拉新与转化活动作为验证场景。

### 2.1 活动名称

**新用户首充激励活动**

### 2.2 业务目标

- **核心目标**: 提升新注册用户首次充值的转化率。
- **次要目标**: 鼓励新用户完成更高金额的首次充值。

### 2.3 活动规则描述

活动面向近期注册的新用户。在活动期间内，用户完成个人首次充值，即可根据充值金额获得不同档位的奖励。具体规则如下：

- **任务**: 完成个人历史第一笔充值。
- **奖励**: 
    - **档位一**: 首次充值金额在 **10元（含）到 100元（不含）**之间，奖励 **5元现金红包**。
    - **档位二**: 首次充值金额 **大于等于100元**，奖励 **20元现金红包**。

所有奖励在用户完成充值后**自动发放**到其账户余额中。每个用户只能参与一次，领取一次奖励。


---

## 3. 原子模板设计 (高阶运营/研发)

现在，我们模拟**高阶运营或研发人员**的角色，为上述活动场景创建所需的基础“积木”——原子模板。这些模板将被存入原子模板库，供一线运营人员后续使用。

### 3.1 任务模板 (Task Template)

我们需要一个能够捕捉“用户首次充值”这一行为的模板。这个模板的核心是监听充值事件，并判断其是否为用户的首次充值。

**任务模板: `TPL_TASK_FIRST_DEPOSIT`**

| 属性 | 设计内容 |
| :--- | :--- |
| **模板名称** | `通用首充任务模板` |
| **模板ID** | `TPL_TASK_FIRST_DEPOSIT` |
| **任务类型** | `DEPOSIT` |
| **逻辑定义** | - **触发事件 (Event)**: 订阅 `event_user_deposit` (用户充值事件)。<br>- **完成条件 (Condition)**: 事件数据中 `is_first_deposit` 字段为 `true`。<br>- **输出数据**: 任务完成时，将事件中的 `deposit_amount` (充值金额) 字段向下游节点传递。 |
| **暴露变量** | 无。该模板的逻辑是普适的，不需要运营在任务层面配置额外变量。 |

> **设计说明**: 这个模板非常通用，它只负责“识别首充行为”并“传递充值金额”，不包含任何与具体金额相关的判断逻辑。这使得它可以被用于任何与“首充”相关的活动中。

### 3.2 奖励模板 (Reward Template)

根据活动规则，我们需要两种不同金额的现金红包。基于v2.0的设计，我们不需要创建两个独立的模板，而是创建一个通用的“现金红包奖励模板”，然后由一线运营在使用时填充具体的金额。

**奖励模板: `TPL_REWARD_CASH_BONUS`**

| 属性 | 设计内容 |
| :--- | :--- |
| **模板名称** | `通用现金红包奖励模板` |
| **模板ID** | `TPL_REWARD_CASH_BONUS` |
| **奖励类型** | `CASH_BONUS` |
| **逻辑定义** | - **执行动作 (Action)**: 调用 `WalletService.addBalance(userId, amount)` 接口。<br>  - `userId` 从上下文中获取。<br>  - `amount` 的值来源于下方定义的暴露变量 `reward_amount`。 |
| **暴露变量** | - **变量名**: `reward_amount`<br>- **显示名称**: `奖励金额`<br>- **控件类型**: `NumberInput`<br>- **校验规则**: `必须大于 0` |

> **设计说明**: 这个模板封装了“发放现金”这一原子能力。运营人员在后续配置活动时，可以像调用函数一样使用它，只需传入 `reward_amount` 这一个参数即可，极大降低了配置门槛。


---

## 4. ECA 逻辑配置 (一线运营)

现在，我们切换到**一线运营人员**的角色。这位运营人员的目标是使用已经创建好的原子模板，来“搭建”出“新用户首充激励活动”。他/她将在“活动组合配置向导”的可视化界面中完成以下操作。

### 4.1 逻辑流程图 (LogicFlow)

运营人员通过拖拽和连接节点，构建出如下的ECA逻辑流程。这本质上是在定义“当某个事件发生后，经过一系列条件判断，最终执行什么动作”。

```mermaid
graph TD
    subgraph "活动组合配置向导"
        E[E: 事件触发<br/>通用首充任务模板<br/>TPL_TASK_FIRST_DEPOSIT]:::event
        
        C1{C: 条件判断 1<br/>充值金额是否在 10元-100元? }:::condition
        C2{C: 条件判断 2<br/>充值金额是否 ≥ 100元? }:::condition
        
        A1[A: 动作执行 1<br/>通用现金红包奖励模板<br/>TPL_REWARD_CASH_BONUS<br/>(参数: reward_amount = 5)]:::action
        A2[A: 动作执行 2<br/>通用现金红包奖励模板<br/>TPL_REWARD_CASH_BONUS<br/>(参数: reward_amount = 20)]:::action
    end

    E -- 任务完成, 输出 deposit_amount --> C1
    C1 -- "是 (true)" --> A1
    C1 -- "否 (false)" --> C2
    C2 -- "是 (true)" --> A2
    C2 -- "否 (false)" --> End((结束))
    A1 --> End
    A2 --> End

    classDef event fill:#B8E0D2,stroke:#2C7A7B,stroke-width:2px,color:black
    classDef condition fill:#FFE5B4,stroke:#D97706,stroke-width:2px,color:black
    classDef action fill:#D1FAE5,stroke:#059669,stroke-width:2px,color:black
```

### 4.2 节点配置详解

以下是运营人员在可视化界面中，对每个节点的具体配置。

| 节点类型 | 节点实例 | 配置详情 |
| :--- | :--- | :--- |
| **事件 (Event)** | `E: 通用首充任务` | - **操作**: 从“任务模板库”中拖拽 `TPL_TASK_FIRST_DEPOSIT` 模板到画布。<br>- **配置**: 无需额外配置，该节点会自动监听用户的首充事件。 |
| **条件 (Condition)** | `C1: 档位一判断` | - **操作**: 添加一个“条件判断”节点，连接到 `E` 节点的输出。<br>- **配置**: 设置判断逻辑为 `input.deposit_amount >= 10 && input.deposit_amount < 100`。这里的 `input` 指的是上游节点（即首充任务节点）传递过来的数据。 |
| **动作 (Action)** | `A1: 发放5元红包` | - **操作**: 从“奖励模板库”中拖拽 `TPL_REWARD_CASH_BONUS` 模板，并连接到 `C1` 的“是”分支。<br>- **配置**: 在该节点的参数面板中，找到暴露的变量 `奖励金额 (reward_amount)`，并填入数字 `5`。 |
| **条件 (Condition)** | `C2: 档位二判断` | - **操作**: 添加第二个“条件判断”节点，连接到 `C1` 的“否”分支。<br>- **配置**: 设置判断逻辑为 `input.deposit_amount >= 100`。 |
| **动作 (Action)** | `A2: 发放20元红包` | - **操作**: 再次从“奖励模板库”中拖拽 `TPL_REWARD_CASH_BONUS` 模板，并连接到 `C2` 的“是”分支。<br>- **配置**: 在该节点的参数面板中，将 `奖励金额 (reward_amount)` 填入数字 `20`。 |

> **设计说明**:
> - **灵活性**: 如果业务调整，需要增加一个“充值满500送100”的档位三，运营只需在 `C2` 的“否”分支后，再追加一个“条件节点”和一个“动作节点”即可，无需研发介入。
> - **复用性**: `TPL_TASK_FIRST_DEPOSIT` 和 `TPL_REWARD_CASH_BONUS` 这两个原子模板在此流程中被直接复用，体现了其价值。
> - **易用性**: 运营人员的核心工作从“理解和编写复杂逻辑”转变为“选择积木、连接流转、填写参数”，心智负担大大降低。


---

## 5. 串联与非ECA配置

完成了核心的ECA逻辑搭建后，运营人员还需要在“活动组合配置向导”的后续步骤中，完成活动的通用信息配置。这些配置不涉及核心逻辑流，但对活动的最终呈现和执行至关重要。

### 5.1 非ECA配置项

| 配置项 | 配置内容 | 说明 |
| :--- | :--- | :--- |
| **活动名称** | `2026新年首充福利` | 用于后台管理和前端展示的活动标题。 |
| **活动时间** | `2026-01-25 00:00:00` 至 `2026-02-10 23:59:59` | 定义活动生效的起止时间。 |
| **目标人群** | - **操作**: 从“人群模板库”选择或手动创建。<br>- **规则**: `注册时间` 在 `2026-01-01` 之后。 | 定义哪些用户可以看到并参与此活动。 |
| **活动入口** | - **类型**: 首页弹窗<br>- **素材**: 上传一张活动主视觉图片。 | 配置活动在C端的展示方式和位置。 |
| **总预算** | - **类型**: 现金<br>- **金额**: `500,000` 元 | 设置活动奖励的总金额上限，用于风控。 |
| **单用户限制** | `每个用户只能参与1次` | 基于 `user_id` 进行限制，确保公平性。 |

### 5.2 生成配置快照 (Configuration Snapshot)

当运营人员点击“发布”按钮并通过所有校验后，系统会执行一个至关重要的动作：**生成配置快照**。系统会将ECA逻辑配置和非ECA配置**合并并解析**，生成一个最终的、可直接被运行时服务执行的JSON对象——`resolved_logic_graph`。

**`resolved_logic_graph` (伪代码示例):**

```json
{
  "activity_id": "ACT_12345",
  "name": "2026新年首充福利",
  "start_time": "2026-01-25 00:00:00",
  "end_time": "2026-02-10 23:59:59",
  "audience_rules": {
    "user_tags": {"registration_time": {"$gte": "2026-01-01"}}
  },
  "budget_limit": 500000,
  "nodes": [
    {
      "id": "node_1",
      "type": "event_trigger",
      "template_id": "TPL_TASK_FIRST_DEPOSIT",
      "params": {},
      "outputs": ["node_2"]
    },
    {
      "id": "node_2",
      "type": "condition_branch",
      "logic": "input.deposit_amount >= 10 && input.deposit_amount < 100",
      "outputs": {"true": "node_3", "false": "node_4"}
    },
    {
      "id": "node_3",
      "type": "action_execute",
      "template_id": "TPL_REWARD_CASH_BONUS",
      "params": {"reward_amount": 5}
    },
    {
      "id": "node_4",
      "type": "condition_branch",
      "logic": "input.deposit_amount >= 100",
      "outputs": {"true": "node_5", "false": null}
    },
    {
      "id": "node_5",
      "type": "action_execute",
      "template_id": "TPL_REWARD_CASH_BONUS",
      "params": {"reward_amount": 20}
    }
  ]
}
```

这份“快照”会被写入 `activity_instance` 表的 `resolved_logic_graph` 字段。**此后，无论上游的原子模板如何修改，都不会影响这个已发布活动的逻辑**，从而保证了线上环境的绝对稳定。


---

## 6. 测试目标与数据追溯

最后，我们需要定义清晰的测试目标，以验证C端用户在参与活动时的表现，并确保所有数据都按预期进行了存储和追溯。

### 6.1 C端用户运行流程测试

我们将模拟三个不同行为的用户来测试系统的反应。

| 测试用户 | 用户行为 | 预期系统表现 |
| :--- | :--- | :--- |
| **用户A (符合档位一)** | 1. 注册账号 (2026-01-26)。<br>2. 首次充值 **50元**。 | 1. 首页出现活动弹窗。<br>2. 充值成功后，账户余额**立即增加5元**。<br>3. 再次充值时，不再触发任何活动奖励。 |
| **用户B (符合档位二)** | 1. 注册账号 (2026-01-27)。<br>2. 首次充值 **200元**。 | 1. 首页出现活动弹窗。<br>2. 充值成功后，账户余额**立即增加20元**。<br>3. 再次充值时，不再触发任何活动奖励。 |
| **用户C (不符合条件)** | 1. 注册账号 (2026-01-28)。<br>2. 首次充值 **5元** (低于最低档位)。 | 1. 首页出现活动弹窗。<br>2. 充值成功后，**无任何奖励**发放。<br>3. 再次充值时，不再触发任何活动奖励。 |
| **用户D (老用户)** | 1. 注册账号 (2025-12-30)。<br>2. 首次充值100元。 | 1. **看不到**活动弹窗。<br>2. 充值成功后，**无任何奖励**发放。 |

### 6.2 数据存储与可追溯性验证

在上述用户完成操作后，我们需要检查后台数据库，以验证数据的存储是否正确、完整，并能够清晰地追溯整个流程。

| 验证项 | 目标数据表 | 需核对的字段与值 |
| :--- | :--- | :--- |
| **用户活动上下文** | `user_activity_context` | - **用户A**: 应存在一条记录 `{activity_id: 'ACT_12345', user_id: 'user_A'}`。<br>  - `context_data` 字段中应记录 `{task_status: 'completed', deposit_amount: 50}`。 |
| **发奖账本** | `reward_ledger` | - **用户A**: 应新增一条记录，`user_id`为'user_A'，`reward_type`为'CASH_BONUS'，`reward_amount`为 **5**，`status`为'SUCCESS'。<br>- **用户B**: 应新增一条记录，`reward_amount`为 **20**。<br>- **用户C/D**: **不应**有任何发奖记录。 |
| **资金安全** | `reward_ledger` | - 所有发奖记录的 `transaction_id` 必须**唯一**，防止重复发放。<br>- `trigger_event_id` 字段应正确关联到触发该笔奖励的充值事件ID。 |
| **活动实例配置** | `activity_instance` | - 检查ID为 `ACT_12345` 的活动实例，其 `resolved_logic_graph` 字段的内容必须与我们设计的JSON快照完全一致。 |

通过完成以上所有测试，我们便可以从**配置端到执行端**，再到**数据端**，完整地验证v2.0设计方案的端到端可行性。
